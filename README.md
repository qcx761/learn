# Linux 虚拟内存和物理内存理解

## 一、虚拟内存

### 第一层理解

1. **每个进程都有自己独立的内存空间**
   - 每个进程都有独立的 4GB 虚拟内存空间。
   - 内存空间结构相似，包含代码段、数据段、堆、栈等。

2. **进程创建时的内存空间**
   - 新进程创建时，会建立自己的内存空间。
   - 进程的数据、代码等从磁盘映射到虚拟内存。
   - 内存空间的分配情况由 `task_struct` 记录，包括哪些地址有数据、哪些可读写。

3. **虚拟内存映射磁盘**
   - 进程分配的内存空间与磁盘文件建立映射。
   - 并非所有数据立即加载到物理内存，按需加载。

---

### 核心问题

> 计算机物理内存有限，如果每个进程都需要 4GB，如何处理？  

1. 每个进程的 4GB 是虚拟内存，通过页表映射到物理内存。
2. 所有进程共享物理内存，只加载需要的数据。
3. 页表记录虚拟地址与物理页的对应关系。
4. 页表项包含两部分：
   - 数据是否在物理内存。
   - 数据在物理内存的地址（如果已加载）。
5. 访问虚拟地址：
   - 若数据不在物理内存 → 缺页异常。
   - 缺页处理：从磁盘加载数据到物理内存；如内存不足，选择页替换（写回磁盘如有修改）。
   
---

### 优点

1. 链接器可以在固定地址生成可执行文件，无需关心物理地址。
2. 不同进程共享相同代码（如库文件），节省内存。
3. 程序需要连续内存时，只需在虚拟空间分配连续地址，不要求物理内存连续，避免碎片。

---

### 延迟加载机制

- 进程创建时，仅建立虚拟内存与磁盘文件映射（存储器映射）。
- 真正访问数据时才触发缺页异常加载到物理内存。
- 用户空间动态分配内存（如 `malloc`）：
  - 仅分配虚拟地址空间。
  - 实际物理内存按需加载。

---

### 虚拟存储器的三个概念

1. **虚拟存储空间**
2. **磁盘空间**
3. **物理内存空间**

> 虚拟空间通过页表映射到磁盘空间，访问数据时通过缺页异常加载到物理内存。

---

### mmap

- 用于建立虚拟地址与磁盘文件的映射。
- 访问映射地址 → 数据加载到物理内存。
- 支持共享内存、读写磁盘文件。

---

## 二、物理内存

### 内核态 vs 用户态内存申请

- 内核态：
  - 申请内存立即满足。
  - 请求被认为合理。
- 用户态：
  - 延迟分配物理内存。
  - 通过虚拟内存获取使用权，访问时触发缺页异常分配物理页。

---

### 物理内存映射（IA32架构）

- 内核虚拟地址空间：3GB~4GB。
- 直接映射 1GB 常规内存。
- 高端内存（>1GB）无法直接映射：
  1. 每个物理页有页框描述符，保存在 `mem_map` 数组。
  2. 分配高端内存时临时映射。

- 内核映射方式：
  - 永久内核映射
  - 固定映射
  - `vmalloc` 机制

---

### 物理内存管理机制

1. **伙伴算法（Buddy）**
   - 分配大块连续内存，避免外部碎片。
   - 页框为基本单位。

2. **Slab 高速缓存**
   - 分配小块内存。
   - 高效管理内核对象，避免内部碎片。
   - 接口：`kmalloc()`（通用）或专用缓存。

3. **vmalloc**
   - 分配非连续物理内存，但虚拟地址连续。
   - 类似用户态虚拟内存机制。
   - 分配立即生效，线性地址连续，物理地址可分散。

---

### 内核内存分配器

1. **分区页框分配器**
   - 前端管理器 + 伙伴系统。
   - 支持 `alloc_pages()` 和 `__get_free_pages()`。

2. **Slab 分配器**
   - 每种对象建立高速缓存。
   - Slab 由页框组成。
   - 内存分配通过伙伴算法提供页框。

3. **非连续内存分配**
   - `vmalloc()`：
     1. 寻找连续虚拟地址空间。
     2. 分配非连续物理页框。
     3. 建立虚拟地址与物理页框映射。

---

### 内存碎片问题

| 类型 | 描述 | 解决方法 |
|------|------|---------|
| 外部碎片 | 足够内存但不连续 | 伙伴算法、`vmalloc` |
| 内部碎片 | 分配大块连续内存浪费 | Slab/SLUB/SLOB |

---

### 常用内存分配函数

| 函数 | 分配区域 | 地址连续性 | 说明 |
|------|----------|------------|------|
| `vmalloc` | 内核虚拟内存 | 虚拟地址连续，物理地址非连续 | 高端内存分配 |
| `kmalloc` | 内核物理内存映射区 | 地址连续 | 小块内存分配，基于伙伴算法 |
| `malloc` | 用户虚拟内存 | 虚拟地址连续 | 1-3GB 用户空间 |

---


## 三、用户空间与内核空间交互

```c
// 1. 内核变量写入到用户空间
put_user(x, ptr); 
// 将内核变量 x 写入用户空间 ptr 所指向的位置
// 可能引起睡眠（阻塞）

// 2. 将用户空间的值写入到内核空间
get_user(x, ptr); 
// 从用户空间 ptr 读取值到内核变量 x

// 3. 从内核空间读取数据到用户空间
copy_to_user(void __user *to, const void *from, unsigned long n);
// 将内核空间 from 中 n 字节数据复制到用户空间 to
// 返回值：0 表示成功，非0表示未拷贝的字节数

// 4. 从用户空间拷贝数据到内核空间
copy_from_user(void *to, const void __user *from, unsigned long n);
// 将用户空间 from 中 n 字节数据复制到内核空间 to

// 5. 检查用户空间内存块是否可用
access_ok(type, addr, size);
// type: VERIFY_READ 或 VERIFY_WRITE
// addr: 用户空间指针，指向待检查内存块起始位置
// size: 要检查的内存块大小
// 返回值：可访问返回非0，否则返回0