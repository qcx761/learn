Linux 虚拟内存与物理内存 —— 30 分钟入门分享
🎯 分享目标

面向刚开始接触 Linux 的同学，用 30 分钟理解：

什么是虚拟内存？

什么是物理内存？

Linux 为什么要用虚拟内存？

虚拟内存和物理内存如何映射？

malloc 背后到底发生了什么？

什么是分页、缺页异常、页表？

swap 有什么作用？

讲完之后大家能对内核内存管理有 清晰直观的理解。

1️⃣ 为什么需要虚拟内存？
💡 现实问题

如果一个程序 直接访问物理内存 会有什么问题？

程序之间容易互相覆盖内存 → 崩溃

程序需要连续大内存很难满足（碎片问题）

程序地址需要跟物理硬件紧密绑定，写程序很痛苦

不能让程序使用超过物理 RAM 的空间

✨ 虚拟内存出现就是为了解决这些问题

虚拟内存 = 给每个程序看到的独立、连续、巨大的内存空间。
程序再也不会看到物理内存的混乱世界。

简单说：

程序看到的内存（虚拟） ≠ 真实内存（物理）

2️⃣ 虚拟内存：每个程序独享的“假象世界”

在 Linux 中，每个进程看到的虚拟地址空间大致长这样：

+--------------------------+
|       栈 Stack           |
+--------------------------+
|      动态库 .so          |
+--------------------------+
|       堆 Heap            |
+--------------------------+
| data 区、bss 区、代码区  |
+--------------------------+
|       内核空间           |
+--------------------------+


特点：

每个进程都有 独立且一致 的结构

程序根本不需要关心物理内存在哪里

3️⃣ 物理内存：真实的 RAM

物理内存是机器上的真实硬件：

是有限的（比如 8GB）

不连续

会被多个程序共享

内核负责分配、回收和保护

程序 永远不能直接访问物理内存，只能通过虚拟内存间接访问。

4️⃣ Linux 如何把虚拟内存映射到物理内存？

靠 页（Page） 和 页表（Page Table）。

🧩 页（Page）

虚拟内存和物理内存都被切成小块

默认大小：4KB

🧩 页表（Page Table）

一个巨大的「字典」

负责记录：虚拟页 → 物理页

当 CPU 访问虚拟地址时：

虚拟地址 → MMU 查页表 → 映射到物理地址


这就是内存访问真正发生的过程。

5️⃣ 分页（Paging）—— Linux 内存管理的核心

分页的三个核心点：

程序使用的虚拟地址被分成一个个虚拟页

内核从物理内存中分配物理页

页表记录虚拟页和物理页之间的映射关系

分页带来优势：

内存隔离（安全）

避免物理内存碎片

支持比 RAM 更大的内存（依赖 swap）

提高内存利用率

6️⃣ 土豪级重点：缺页异常（Page Fault）

🔔 这是理解虚拟内存最关键的概念！

当程序访问一个虚拟地址，但该页：

没有物理页，或

放在 swap 里，

就会发生 缺页异常。

缺页异常流程：

CPU 发现页表里找不到映射 → 触发异常

内核介入，判断情况

若合法访问 → 分配新的物理页

若不合法 → Segmentation Fault（熟悉吧？）

物理内存大多数情况下是在缺页时分配的，而不是在 malloc 时！

7️⃣ malloc 与虚拟内存、物理内存的关系（超重要）
🔹 malloc 做了什么？

当你写：

p = malloc(1024);


malloc 并不会分配物理内存，它会：

检查堆空间是否够

不够则调用 brk/mmap 向内核要一块 虚拟地址区域（VMA）

⚠️ 注意：此时没有物理内存。

🔹 什么时候分配物理内存？

当你第一次访问这块区域时：

p[0] = 1;


发生：

缺页异常

内核分配物理页

页表建立映射

这叫 按需分配（Demand Paging）。

8️⃣ swap —— 虚拟内存的“外部仓库”

当物理内存不够：

内核把冷门的页写到 swap（磁盘）

释放物理页给热点内存

再次访问时会把 swap 页调回（很慢）

有了 swap：

进程可以看到超过 RAM 的空间

系统不会轻易 OOM

但缺点：

性能会变差（磁盘远比内存慢）

9️⃣ 整体流程图（30 分钟最清晰的一张）
malloc
  ↓
内核分配一段虚拟内存（VMA）
  ↓
程序还没访问 → 不分配物理内存
  ↓（第一次访问）
触发缺页异常 Page Fault
  ↓
内核分配物理页
  ↓
建立虚拟页 → 物理页映射
  ↓
后续访问直接命中页表

🔟 总结（适合在分享最后 1 分钟讲）

程序看到的是虚拟内存，不是物理内存

虚拟内存让程序觉得有连续、安全、大空间

内核用 页 和 页表 管理虚拟 → 物理的映射

malloc 只分配虚拟内存

物理内存是在第一次访问时分配（缺页异常）

swap 扩展了内存但速度慢

分页机制让内存管理高效、灵活、安全

一句话总结：
虚拟内存是程序看到的世界，物理内存是现实世界，而 Linux 内核是两者之间的“翻译官”和“调度者”。