# Linux 虚拟内存与物理内存

## 分享内容

- 什么是虚拟内存和物理内存
- Linux 为什么要用虚拟内存
- 虚拟内存和物理内存如何映射
- 页表、分页、缺页异常
- `malloc` 背后到底发生了什么

---

## 1.物理内存

物理内存就是计算机主板上的真实内存硬件。
它是 CPU 在运行程序时实际读写的数据存放地。

- 特点：
  - 容量有限：物理内存大小固定，例如 4GB、8GB 等。物理内存不足时，操作系统必须借助 swap 或其他机制才能继续运行程序。
  - 易失性：断电后数据会丢失，因此不适合作长期存储。
  - 共享性：所有进程共享同一块物理内存，由内核调度和管理，防止互相覆盖。

- 局限性
  - 容量受限：大型程序可能一次性需要数十 GB 内存，但物理内存不够。
  - 碎片问题：频繁分配和释放内存可能导致内存碎片，降低可用性。
  - 安全问题：程序之间直接共享物理内存容易互相覆盖。
  - 硬件依赖：程序必须根据硬件地址操作内存，移植性差。

---

## 2.虚拟内存

虚拟内存是操作系统为每个进程提供的、独立的、连续的 “假象内存空间”。
它让每个进程以为自己拥有一块大的、不受干扰的独立内存。

- 特点：
  - 每个进程独享虚拟地址空间，不同进程之间不会互相干扰。
  - 虚拟内存看起来连续，但实际上可能映射到分散的物理内存
  - 大小通常远大于物理内存（例如 128TB 虚拟空间 → 只有 16GB 物理内存）
  - 虚拟内存只是“地址”，它本身不存储数据。


在 Linux 中，每个进程看到的虚拟地址空间大致如下：

```
高地址
+--------------------------+ 
|           栈             | → 保存函数调用现场、局部变量、返回地址
+--------------------------+
|         动态库            | → 程序运行时通过 mmap 映射的共享库，如 libc、libm
+--------------------------+
|           堆             | → malloc 分配的内存
+--------------------------+
|         data 区          | → 存放已初始化的全局变量和静态变量
|         bss 区           | → 存放未初始化的全局变量
|         代码区            | → 程序的可执行指令
+--------------------------+
|        内核空间           | → 内核代码、数据结构、系统调用实现（用户态不可访问）
+--------------------------+
低地址
```
---

## 3.为什么需要虚拟内存？

### 问题

如果一个程序 直接访问物理内存 会有什么问题？

- 程序之间容易互相覆盖内存导致崩溃
- 程序需要连续大内存很难满足（碎片问题）
- 程序地址需要跟物理硬件紧密绑定，不好写程序
- 不能让程序使用超过物理 RAM 的空间

### 虚拟内存的意义
  
虚拟内存是操作系统为每个进程提供的、与实际物理内存**无关的、独立的、连续的大型**地址空间。它本质是一种 抽象，并不真实存在于硬件里。

> 程序看到的内存（虚拟） ≠ 真实内存（物理）

---

## 4.Linux 如何把虚拟内存映射到物理内存？

Linux 使用 **分页机制** 来管理虚拟内存和物理内存。核心概念是：虚拟地址 → 页表 → 物理页框。访问未映射的页会触发 **缺页异常（Page Fault）**。

### 页

- 虚拟内存和物理内存都被切成小块
- 默认大小：4KB

### 页表

记录了

> 虚拟页 → 物理页

访问流程：

虚拟地址  
→ MMU 查页表  
→ 映射到物理地址

---

## 分页

分页的三个核心点：

1. 程序的虚拟地址被分成虚拟页
2. 内核从物理内存中分配物理页
3. 页表记录虚拟页和物理页的对应关系

分页的优势：

- 内存隔离（安全）
- 避免物理内存碎片
- 支持比 RAM 更大的空间（依赖 swap）
- 提高内存利用率

---

## 缺页异常

当进程访问某个虚拟地址，而该页：

- 没有物理页，或
- 在 swap 里

就会发生 **缺页异常（Page Fault）**。

### 缺页异常流程：

1. CPU 查页表没有映射 → 触发缺页异常
2. 内核介入判断合法性
3. 若合法 → 分配物理页并更新页表
4. 若不合法 → `Segmentation Fault`

**物理内存大多数是在缺页时分配的，而不是在 malloc 时**

---

## 5.malloc 与虚拟内存、物理内存的关系

### 🔹 malloc 做了什么？

当你写：

```c
p = malloc(2025);
```

`malloc` 并不会分配物理内存。

而是：

- 检查堆空间是否够
  - 如果堆里有空闲块 → 直接返回地址
- 不够则调用 `brk` / `mmap` 向内核申请一段 **虚拟地址区域**

此时没有物理内存

### 🔹 什么时候分配物理内存？

当你 **第一次访问** 这片区域：

```c
p[0] = 1;
```

会导致：

1. 触发缺页异常
2. 内核分配物理页
3. 页表建立映射

---

## 整体流程图

```
malloc
  ↓
内核分配一段虚拟内存
  ↓
程序未访问 → 不分配物理内存
  ↓（第一次访问）
触发缺页异常 Page Fault
  ↓
内核分配物理页
  ↓
建立虚拟页 → 物理页映射
  ↓
后续访问直接命中页表
```
---





## 总结

- 程序看到的是 **虚拟内存**，不是物理内存
- 虚拟内存让程序觉得有连续、安全、大空间
- 内核用 **页 + 页表** 管理虚拟 → 物理映射
- `malloc` 只分配虚拟内存
- **物理内存是在第一次访问时分配（缺页异常）**
- 分页让内存管理高效、灵活、安全

