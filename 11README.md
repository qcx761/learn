1. 引言（2 分钟）

大家好，今天我来给大家讲一下 Linux 中虚拟内存与物理内存的关系。

这是操作系统中最重要、最基础的概念之一。
为什么程序可以看到超大的内存？
为什么每个程序都有自己的独立空间？
为什么 malloc 不会直接崩溃？
这些问题都离不开虚拟内存。

2. 物理内存（3 分钟）

我们首先从最简单的开始：物理内存，也就是主板上真正存在的那几条内存条（RAM）。

物理内存的特点非常直接：

容量有限，比如 4GB、8GB、16GB。

所有进程都必须共享这块物理内存。

数据断电就会丢失。

物理内存地址是连续的硬件地址。

它也有几个明显的缺点：

容量太有限，很多大型程序可能需要几十 GB。

安全问题，如果所有程序都直接访问物理地址，很容易互相覆盖。

碎片严重，物理内存区域是零散的，大块连续内存很难找到。

这一切都说明：
让进程直接操作物理内存，不可能构建出一个稳定、安全的系统。

3. 虚拟内存（4 分钟）

虚拟内存出现，就是为了解决这些问题。

虚拟内存是操作系统+CPU 一起给每个进程创建的一块 独立的、连续的、巨大的、假的地址空间。

关键点：

每个进程看到的虚拟内存都一样，好像独占整个系统。

虚拟内存并不真实存在，它只是一套地址编号。

只有访问时，才会映射到实际物理内存。

虚拟内存空间可以比物理内存大得多，例如 128TB。

程序永远只看到简单、连续、干净的一大片空间，而背后由操作系统和硬件来处理实际的物理映射和分配。

4. 虚拟地址空间布局（3 分钟）

用 Linux 的虚拟内存布局图来看更清晰：

高地址
+--------------------------+
|           栈             |
|        (向下增长)         |
+--------------------------+
|           堆             |
|        (向上增长)         |
+--------------------------+
|        BSS 段            |
+--------------------------+
|        Data 段           |
+--------------------------+
|        Text 段           |
+--------------------------+
|       内核空间            |
+--------------------------+
低地址


每个进程看到的就是这样一块结构化的空间。

Text 段：代码

Data / BSS：全局变量

堆：malloc 申请的区域

栈：函数调用用的区域

内核空间：用户程序不可访问

所有进程的虚拟布局都一样，但实际映射到的物理内存完全不同。

5. 为什么需要虚拟内存（4 分钟）

如果程序直接操作物理内存，会出现几个严重问题：

① 进程之间无法隔离

A 程序写错地址会覆盖 B 程序的数据，系统瞬间崩溃。

② 很难提供连续内存

物理内存碎片严重，程序要求说“我要 500MB 连续空间”，硬件基本做不到。

③ 可移植性差

程序要关心真实的硬件地址，非常难写。

④ 物理内存不够用

虚拟内存让程序“以为”自己有很多内存，真正访问时才分配物理页。
还可以用 swap 来扩展。

虚拟内存把所有这些困难都屏蔽掉，让程序运行在一个干净的抽象世界中。

6. 分页机制（5 分钟）

有了虚拟内存，还需要一种方式把虚拟地址映射到物理地址。

Linux 用的是 分页机制：

虚拟内存被切成一页一页的（4KB）

物理内存也被切成一样大小的页框

映射关系由 页表 记录

流程是：

虚拟地址 → 页号 + 页内偏移 → 页表查映射 → 物理页框

分页的两个巨大优势：

① 不需要物理内存连续

虚拟地址连续没关系，物理内存可以完全分散。

② 按需分配

程序第一次访问虚拟页时，才分配物理页。
这大大提高了内存利用率。

7. 多级页表（4 分钟）

一个 64 位进程虚拟空间非常大，直接用一个巨大页表是不可能的。

所以使用 多级页表结构。

例如常见的 4 级结构：

PGD（顶级目录）

PUD

PMD

PTE（页表入口）

每一级都只覆盖虚拟地址的一部分。
优点是非常节省内存：

未使用的地址区不需要创建对应的下级页表。

虚拟空间可以很稀疏，但页表不会爆炸。

这就是为什么 Linux 可以支持 128TB 虚拟空间，但页表内存占用仍然可控。

8. 缺页异常（3 分钟）

程序访问一个虚拟地址时，CPU 会查页表：

如果该页还没有映射 → 缺页异常

操作系统介入

为该虚拟页分配物理页

更新页表，然后恢复执行

缺页异常让 按需分配 成为可能：

malloc 开那么大空间不会立刻消耗物理内存

只有真正访问时才会占用 RAM

也因此，虚拟内存可以“假装很大”。

9. malloc 与虚拟/物理内存关系（2–3 分钟）

最后，看一个大家最熟悉的例子——malloc。

当你写：

p = malloc(2025);


malloc 做的事是：

给你划一段虚拟地址空间
这一步完全不涉及物理内存。

第一次访问时触发缺页异常

p[0] = 1;


CPU 发现该页没有物理映射

内核分配物理页

更新页表

至此，这块虚拟地址才真正对应到了物理内存。

所以：

malloc 分配虚拟内存
缺页异常分配物理内存

这就是所谓的 延迟分配 / 按需分配。

10. 总结（1 分钟）

我们总结一下今天讲的内容：

物理内存是真实硬件，容量有限且碎片严重

虚拟内存给每个进程提供独立、连续、巨大的空间

分页机制实现虚拟地址到物理地址映射

多级页表节省内存，适合超大虚拟空间

缺页异常让物理内存按需分配

malloc 分配虚拟地址，访问时才分配物理页

虚拟内存让程序世界变得更简单、更安全、更高效，是操作系统的重要基石。