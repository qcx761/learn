# Linux 虚拟内存与物理内存 —— 全面理解

本文将从虚拟内存、物理内存、内核内存管理机制、用户态与内核态交互等多个角度，完整解释 Linux 的内存管理体系。

---

# 一、虚拟内存（Virtual Memory）

## 1. 虚拟内存的第一层理解

### 1. 每个进程都有独立的虚拟地址空间

- 每个进程拥有 **独立的 4GB 虚拟地址空间（32 位）**。
- 该空间包含：
  - 代码段（text）
  - 数据段（data/bss）
  - 堆（heap）
  - 栈（stack）
  - 动态库映射区
  - 内核地址映射区（3–4GB）

### 2. 进程创建时的虚拟内存布局

- 新进程创建时，内核为其建立独立的虚拟内存空间。
- 可执行文件的代码、数据并不会一次性读入物理内存，而是：
  - 建立虚拟地址 ↔ 磁盘文件的映射（mmap）
  - 访问时按需加载（缺页异常）

- 内核使用 `task_struct` 记录：
  - 进程虚拟地址空间布局
  - 哪些区域可读/可写/可执行
  - 区域由一系列 VMA（Virtual Memory Area）表示

---

## 2. 虚拟内存按需加载（Demand Paging）

> 物理内存有限，进程虚拟内存高达 4GB，怎么做到的？

方式如下：

1. 每个进程的 4GB 是虚拟的，通过页表映射到实际物理内存。
2. 物理内存由所有进程共享。
3. 页表项（PTE）记录：
   - 该虚拟页是否在物理内存（Present bit）
   - 如果在，则存储其物理页号
4. 当访问虚拟地址时：
   - **若数据不在物理内存 → 触发缺页异常 Page Fault**
   - 内核将数据从磁盘调入内存
   - 若物理内存不足，则执行页替换（swap 或回收）

---

## 3. 虚拟内存的优点

1. 链接器无需关心物理内存布局。
2. 程序看到连续内存，但物理内存可以不连续 → 避免碎片。
3. 允许多个进程共享同一个代码段（如 glibc）。
4. 可支持比实际 RAM 更大的内存（依赖 swap）。

---

## 4. 延迟加载机制（Lazy Allocation）

### 程序启动

- 仅建立虚拟地址与文件的映射，不加载实际内容。

### `malloc()` 行为

```c
p = malloc(1024);
```

- malloc **只分配虚拟地址空间**（VMA）
- 并不会立即分配物理内存
- 第一次访问时触发缺页 → 分配物理页

这是典型的 **按需分配（Demand Paging）**。

---

## 5. 虚拟存储器的三个核心概念

1. **虚拟存储空间（虚拟地址）**
2. **磁盘空间（程序文件、匿名页 swap）**
3. **物理内存空间（RAM）**

虚拟地址通过页表映射到磁盘，当访问时再映射到物理内存。

---

## 6. mmap —— 虚拟地址空间映射机制

`mmap()` 用于建立：

- 虚拟地址 ↔ 文件
- 虚拟地址 ↔ 匿名内存（如 malloc 底层）

访问时才会分配物理页。

用途：

- 文件读取
- 共享内存
- 动态库加载
- 大内存分配

---

# 二、物理内存（Physical Memory）

## 1. 用户态 vs 内核态内存申请

### 用户态：

- `malloc()` 只分配虚拟内存
- 物理内存在首次访问时分配（缺页异常）

### 内核态：

- 内核的内存请求必须立即满足
- 直接分配物理页（不能等缺页异常）

---

## 2. IA-32 架构的物理内存映射（经典 32 位 Linux）

- `0xC0000000~0xFFFFFFFF`: 内核空间（1GB）
- 内核通过固定映射将前 896MB 物理内存对应映射到虚拟地址
- 高端内存（>896MB）需通过临时映射访问

每个物理页对应一个页框描述符 `struct page`，保存在 `mem_map[]` 中。

---

## 3. 物理内存分配算法

### 1) 伙伴算法（Buddy System）

- 基于 2 的幂次分配物理页
- 解决外部碎片
- 分配单位：页框（4KB）

### 2) Slab / SLUB / SLOB 分配器

- 分配小块内存
- 为内核对象（inode、task_struct 等）建立缓存池
- 减少内部碎片和频繁初始化

### 3) vmalloc

- 分配 **虚拟地址连续、物理地址不连续** 的内存空间
- 类似用户态虚拟内存方式
- 使用页表进行映射

对比：

| 函数      | 虚拟地址 | 物理地址 | 用途 |
|-----------|----------|----------|------|
| kmalloc   | 连续     | 连续     | 高性能、适合小块 |
| vmalloc   | 连续     | 不连续   | 大块内存 |
| malloc    | 连续     | 不保证   | 用户态分配 |

---

## 4. 内存碎片问题

| 类型 | 描述 | 解决方法 |
|------|------|---------|
| 外部碎片 | 有足够内存但不连续 | 伙伴算法、vmalloc |
| 内部碎片 | 分配大块但使用部分 | Slab/SLUB |

---

# 三、用户空间与内核空间数据交互

```c
// 1. 将内核变量写入用户空间
put_user(x, ptr);  

// 2. 从用户空间读数据到内核变量
get_user(x, ptr);  

// 3. 拷贝内核数据到用户空间
copy_to_user(void __user *to, const void *from, unsigned long n);

// 4. 拷贝用户数据到内核空间
copy_from_user(void *to, const void __user *from, unsigned long n);

// 5. 检查用户地址是否合法
access_ok(type, addr, size);
```

说明：

- 用户态缓冲区不可直接访问，需通过上述接口
- 可能发生缺页或阻塞
- 内核必须确保用户指针有效，避免安全问题

---

# 四、整体流程图：从虚拟地址到物理内存

```
进程启动
  ↓
建立虚拟内存布局（VMA）
  ↓
实际数据未加载（按需加载）
  ↓
访问虚拟地址
  ↓
查页表
  ↓
若未命中 → 缺页异常
  ↓
分配物理页 → 填充页表
  ↓
返回继续执行
```

---

# 五、总结（最核心记住以下几点）

1. 每个进程拥有独立虚拟地址空间。
2. 虚拟内存不等于物理内存，物理内存被所有进程共享。
3. 缺页异常是物理内存分配的关键机制。
4. malloc 分配的只是虚拟内存。
5. 内核态分配立即生效，用户态按需分配。
6. 伙伴算法 + SLAB + vmalloc 构成内核主要内存管理体系。

一句话总结：

> **虚拟内存是每个进程看到的世界，物理内存是现实，Linux 内核是中间的翻译官与调度者。**

